{"result":0,"data":{"rows":[{"_id":"5875cbf2e18908371467adae","title":"在node.js中生成svg格式的验证码","author":"lemonce","before":"在node.js中生成svg格式的验证码","content":"<p><img src=\"https://raw.githubusercontent.com/lemonce/svg-captcha/master/media/header.png\" alt=\"svg-captcha\"></p>\n<h1 id=\"svg-\">svg验证码</h1>\n<p><a href=\"https://travis-ci.org/steambap/svg-captcha\"><img src=\"https://travis-ci.org/lemonce/svg-captcha.svg?branch=master\" alt=\"Build Status\"></a></p>\n<p>在node.js中生成svg格式的验证码</p>\n<h2 id=\"translations\">Translations</h2>\n<p><a href=\"README_CN.md\">中文</a></p>\n<h2 id=\"-svg-\">什么情况下使用SVG验证码？</h2>\n<ul>\n<li>无法使用 google recaptcha</li>\n<li>无法安装 c++ 模块</li>\n</ul>\n<h2 id=\"-\">安装</h2>\n<blockquote>\n<p>npm install --save svg-captcha</p>\n</blockquote>\n<h2 id=\"-\">使用方法</h2>\n<pre><code class=\"lang-js\">var svgCaptcha = require(&#39;svg-captcha&#39;);\n\nvar c = svgCaptcha.create();\nconsole.log(c);\n// {data: &#39;&lt;svg.../svg&gt;&#39;, text: &#39;abcd&#39;}\n</code></pre>\n<p>在 express中使用</p>\n<pre><code class=\"lang-Javascript\">var svgCaptcha = require(&#39;svg-captcha&#39;);\n\napp.get(&#39;/captcha&#39;, function (req, res) {\n    var captcha = svgCaptcha.create();\n    req.session.captcha = captcha.text;\n\n    res.set(&#39;Content-Type&#39;, &#39;image/svg+xml&#39;);\n    res.status(200).send(captcha.data);\n});\n</code></pre>\n<h2 id=\"api\">API</h2>\n<p><code>svgCaptcha.create(options)</code><br>如果没有任何参数，则生成的 svg 图片有4个字符。  </p>\n<p>options: object<br>{<br>&nbsp;&nbsp;size: 4 // 验证码长度<br>&nbsp;&nbsp;ignoreChars: &#39;0o1i&#39; // 验证码字符中排除 0o1i<br>&nbsp;&nbsp;noise: 1 // 干扰线条的数量<br>&nbsp;&nbsp;color: true // 验证码的字符是否有颜色，默认没有，如果设定了背景，则默认有<br>&nbsp;&nbsp;background: &#39;#cc9966&#39; // 验证码图片背景颜色<br>}</p>\n<p>以上配置对象会用来调用以下两个接口<br><code>svgCaptcha.randomText([size|options])</code><br><code>svgCaptcha(text, options)</code><br>在 1.1.0 版本之前你需要调用上面的两个接口，但是现在只需要调用 create()<br>一个接口就行，可以少打几个字了 (^_^)/</p>\n<p><code>返回:</code> 对象<br>(属性) data: string<br>(属性) text: string  </p>\n<p><code>svgCaptcha.createMathExpr(options)</code><br>和前面的 api 的参数和返回值都一样。不同的是这个 api 生成的 svg 是一个算数式，而\ntext 属性上是算数式的结果。不过用法和之前是完全一样的。</p>\n<h2 id=\"-\">图片示例</h2>\n<p>默认生成图片：</p>\n<p><img src=\"https://raw.githubusercontent.com/lemonce/svg-captcha/master/media/example.png\" alt=\"image\"></p>\n<p>生成数学公式并且有颜色的验证码：</p>\n<p><img src=\"https://raw.githubusercontent.com/lemonce/svg-captcha/master/media/example-2.png\" alt=\"image2\"></p>\n<h2 id=\"-svg-\">为什么使用 svg 格式?</h2>\n<p>不需要引用 c++ 模块。<br>如果你认为可以用正则匹配text标签，那就大错特错了。\n这个项目使用了opentype.js，把文字转化为了路径。<br>换句话说，你得到的是\n&#39;&lt;path fill=&quot;#444&quot; d=&quot;M104.83 19.74L107.85 19.74L112 33.56L116.13 19.74L119.15 19.74L113.48 36.85...&#39;\n这样的路径，没有text标签。所以SVG验证码可能比的图片普通验证码要更难识别，因为你必须先做SVG到其它格式的转化。</p>\n<h2 id=\"license\">License</h2>\n<p><a href=\"LICENSE.md\">MIT</a></p>\n","origin":"![svg-captcha](https://raw.githubusercontent.com/lemonce/svg-captcha/master/media/header.png)\n\n# svg验证码\n\n[![Build Status](https://travis-ci.org/lemonce/svg-captcha.svg?branch=master)](https://travis-ci.org/steambap/svg-captcha)\n\n在node.js中生成svg格式的验证码\n\n## Translations\n[中文](README_CN.md)\n\n## 什么情况下使用SVG验证码？\n\n- 无法使用 google recaptcha\n- 无法安装 c++ 模块\n\n## 安装\n> npm install --save svg-captcha\n\n## 使用方法\n```js\nvar svgCaptcha = require('svg-captcha');\n\nvar c = svgCaptcha.create();\nconsole.log(c);\n// {data: '<svg.../svg>', text: 'abcd'}\n```\n在 express中使用\n```Javascript\nvar svgCaptcha = require('svg-captcha');\n\napp.get('/captcha', function (req, res) {\n\tvar captcha = svgCaptcha.create();\n\treq.session.captcha = captcha.text;\n\t\n\tres.set('Content-Type', 'image/svg+xml');\n\tres.status(200).send(captcha.data);\n});\n```\n\n## API\n`svgCaptcha.create(options)`  \n如果没有任何参数，则生成的 svg 图片有4个字符。  \n  \noptions: object  \n{  \n&nbsp;&nbsp;size: 4 // 验证码长度  \n&nbsp;&nbsp;ignoreChars: '0o1i' // 验证码字符中排除 0o1i  \n&nbsp;&nbsp;noise: 1 // 干扰线条的数量  \n&nbsp;&nbsp;color: true // 验证码的字符是否有颜色，默认没有，如果设定了背景，则默认有  \n&nbsp;&nbsp;background: '#cc9966' // 验证码图片背景颜色  \n}\n\n以上配置对象会用来调用以下两个接口  \n`svgCaptcha.randomText([size|options])`  \n`svgCaptcha(text, options)`  \n在 1.1.0 版本之前你需要调用上面的两个接口，但是现在只需要调用 create()  \n一个接口就行，可以少打几个字了 (^_^)/\n\n`返回:` 对象  \n(属性) data: string  \n(属性) text: string  \n\n`svgCaptcha.createMathExpr(options)`  \n和前面的 api 的参数和返回值都一样。不同的是这个 api 生成的 svg 是一个算数式，而\ntext 属性上是算数式的结果。不过用法和之前是完全一样的。\n\n## 图片示例\n默认生成图片：\n\n![image](https://raw.githubusercontent.com/lemonce/svg-captcha/master/media/example.png)\n\n生成数学公式并且有颜色的验证码：\n\n![image2](https://raw.githubusercontent.com/lemonce/svg-captcha/master/media/example-2.png)\n\n## 为什么使用 svg 格式?\n\n不需要引用 c++ 模块。  \n如果你认为可以用正则匹配text标签，那就大错特错了。\n这个项目使用了opentype.js，把文字转化为了路径。  \n换句话说，你得到的是\n'&lt;path fill=\"#444\" d=\"M104.83 19.74L107.85 19.74L112 33.56L116.13 19.74L119.15 19.74L113.48 36.85...'\n这样的路径，没有text标签。所以SVG验证码可能比的图片普通验证码要更难识别，因为你必须先做SVG到其它格式的转化。\n\n## License\n[MIT](LICENSE.md)","__v":0,"deleted":false,"publishDate":"2017-01-11T06:08:50.395Z","id":"7b0d207b-d3c2-4b4d-9bd6-cf855c192a10"},{"_id":"587348150860543e580926ef","title":"项目简介","author":"unclemeric","before":"本项目说明","content":"<h2 id=\"react-personal-blog\">React-Personal-Blog</h2>\n<p>用react写的个人博客</p>\n<h2 id=\"-\">目录</h2>\n<pre><code>|   .eslintignore   \n|   .eslintrc\n|   .gitignore\n|   app.js                                                              express生产环境单页面入口文件\n|   appMultiplePageDev.js                                               express多页面测试环境入口文件\n|   appMultiplePagePro.js                                               express多页面生产环境入口文件\n|   config.js                                                           项目内部配置文件(接口api、页面配置等)\n|   favicon.ico\n|   package.json\n|   ReactMarkdown.md\n|   README.md                                                           说明文档\n|   webpack.config.dev.js                                               webpack单页面测试环境配置文件\n|   webpack.config.dev.multiplepage.js                                  webpack多页面测试环境配置文件\n|   webpack.config.js                                                   webpack单页面生产环境配置文件\n|   webpack.config.pro.multiplepage.js                                  webpack多页面生产环境配置文件\n|\n\\---src                                                                 代码根目录\n    |   admin-index.js                                                  admin后台入口文件\n    |   entry.js                                                        tes1页面入口文件\n    |   index-style.scss                                                \n    |   index.html                                                      页面模板文件\n    |   index.js                                                        前台页面入口文件\n    |\n    +---component                                                       组件目录\n    |   +---Admin                                                       admin后台组件目录\n    |   |   |   index.scss\n    |   |   |\n    |   |   +---Home                                                    \n    |   |   |   |   index.js\n    |   |   |   |   style.scss\n    |   |   |   |\n    |   |   |   \\---Articles                                            文章编辑列表组件\n    |   |   |           edit.js                                         文章编辑组件\n    |   |   |           index.js                                        文章列表\n    |   |   |           style.scss\n    |   |   |\n    |   |   +---LeftNav                                                 左边菜单栏\n    |   |   |       index.js\n    |   |   |       index.scss\n    |   |   |\n    |   |   \\---PublishArticle                                          发布文章组件\n    |   |           index.js\n    |   |           style.scss\n    |   |\n    |   +---Articles                                                    前台文章\n    |   |   |   index.js                                                前台文章列表组件\n    |   |   |   style.scss\n    |   |   |\n    |   |   \\---Article                                                 前台文章内容页\n    |   |           index.js\n    |   |\n    |   +---ConnectMe                                                   前台联系我组件\n    |   |       index.js\n    |   |\n    |   +---FeedBack                                                    前台反馈组件\n    |   |       index.js\n    |   |       style.scss\n    |   |\n    |   +---MDEditor                                                    markdown编辑器容器(可自定义，markdown主要代码不在这)\n    |   |       index.js\n    |   |\n    |   +---MyPagination                                                分页组件\n    |   |       index.js\n    |   |       style.scss\n    |   |\n    |   +---Notes\n    |   |       index.js\n    |   |       style.scss\n    |   |\n    |   +---PageFooter                                                  页尾\n    |   |       index.js\n    |   |       style.scss\n    |   |\n    |   +---PageHeader                                                  页头容器\n    |   |   |   index.js\n    |   |   |   style.scss\n    |   |   |\n    |   |   +---Header                                                  页头\n    |   |   |       index.js\n    |   |   |       style.scss\n    |   |   |\n    |   |   \\---HeaderNav                                               页头导航菜单\n    |   |           index.js\n    |   |           style.scss\n    |   |\n    |   +---PageIndex                                                   首页\n    |   |   |   index.js\n    |   |   |   style.scss\n    |   |   |\n    |   |   \\---IndexContent                                            首页内容\n    |   |           index.js\n    |   |           style.scss\n    |   |\n    |   \\---Profile                                                     个人资料\n    |           index.js\n    |           style.scss\n    |\n    +---config                                                          个人资料配置文件\n    |       profileConfig.js\n    |\n    +---lib                                                             markdown组件\n    |       editor.js\n    |       editor.less\n    |\n    +---static\n    |   +---css\n    |   |       amazeui.min.css\n    |   |       base.scss\n    |   |       codemirror.css                                          markdown样式文件\n    |   |\n    |   +---fonts\n    |   |       fontawesome-webfont.woff2\n    |   |\n    |   +---images\n    |   |       header.png\n    |   |       logo.png\n    |   |       profile_ico_b.png\n    |   |\n    |   \\---scss\n    |           component.scss                                          markdown sass文件\n    |           index.scss\n    |\n    \\---utils\n            amazeutil.js\n            autoChange.js\n            DataUtils.js\n</code></pre><h2 id=\"webpack-\">webpack配置文件说明</h2>\n<pre><code>webpack.config.js：用于生产环境编译文件。\nwebpack.config.dev.js：用于开发阶段编译文件。修改react文件之后会自动编译  不需要手动编译\n</code></pre><h2 id=\"-\">功能</h2>\n<p><strong><em>markdown文本编辑功能</em></strong></p>\n<p><strong>关于eslint的使用</strong></p>\n<pre><code>作用：为避免低级 Bug、产出风格统一的代码，会预先制定编码规范。使用 Lint 工具和代码风格检测工具，则可以辅助编码规范执行，有效控制代码质量。\n\nps：由于第一次使用，还有很多规则没有写到，没写到的可以自己在.eslintrc配置文件增加。eslint会使在编写代码的时候会遇到很多问题...头疼，但是使用这个能是代码更规范！\n不需要的可以在webpack配置文件里面去掉下面两个配置：\npreLoaders: [\n  {\n    // Eslint loader\n    test: /\\.js?$/,\n    loader: &#39;eslint-loader&#39;,\n    include: [path.resolve(__dirname, &#39;src&#39;)],\n    exclude: [/node_modules/,path.resolve(__dirname, &#39;src/utils&#39;)],\n  },\n],\neslint: {\n  configFile: &#39;.eslintrc&#39;,\n},\n</code></pre><p>关于appMultiplePage.js和webpack.config.dev.multiplepage.js的说明</p>\n<pre><code>&quot;deploy-dev&quot;: &quot;webpack -p --progress --colors&quot;,\n&quot;deploy-dev-server&quot;: &quot;webpack-dev-server --config webpack.config.dev.js --progress --colors&quot;,                                                                 //开发环境单页面启动脚本\n&quot;deploy-server&quot;: &quot;webpack -p --config webpack.config.js --progress --colors&amp;&amp;nodemon app.js&quot;,                                                                 //生产环境单页面启动脚本\n&quot;multiple-page-dev&quot;: &quot;node ./appMultiplePageDev.js&quot;,                                                                                                          //开发环境多页面的服务启动入口脚本，根据配置文件的projectConf配置生成路由服务，结合react热加载，不需要手动重新编译，但是需要手动刷新页面。\n&quot;multiple-page-pro&quot;: &quot;webpack -p --config webpack.config.pro.multiplepage.js&amp;&amp;node ./appMultiplePagePro.js&quot;                                                   //生产环境多页面服务启动脚本\n\nappMultiplePage.js：一个react多页面的服务启动入口js，根据配置文件的projectConf配置生成路由服务，结合react热加载，不需要手动重新编译，但是需要手动刷新页面。\nwebpack.config.dev.multiplepage.js：根据配置(config.js)自动生成多个页面的webpack配置文件\n\n多页面启动方式：\n先执行webpack --config webpack.config.dev.multiplepage.js --progress --color 编译项目，再启动多页面服务nodemon appMultiplePage.js\n或者执行script脚本npm run multiple-page-build再执行npm run nodemon appMultiplePage.js\n</code></pre><hr>\n<p>2016/12/23 </p>\n<ul>\n<li>增加<a href=\"https://github.com/leozdgao/react-markdown\">markdown编辑器</a>功能</li>\n<li>修改之前抽离css不成功bug</li>\n</ul>\n","origin":"## React-Personal-Blog\n\n用react写的个人博客\n\n## 目录\n\n```\n|   .eslintignore   \n|   .eslintrc\n|   .gitignore\n|   app.js                                                              express生产环境单页面入口文件\n|   appMultiplePageDev.js                                               express多页面测试环境入口文件\n|   appMultiplePagePro.js                                               express多页面生产环境入口文件\n|   config.js                                                           项目内部配置文件(接口api、页面配置等)\n|   favicon.ico\n|   package.json\n|   ReactMarkdown.md\n|   README.md                                                           说明文档\n|   webpack.config.dev.js                                               webpack单页面测试环境配置文件\n|   webpack.config.dev.multiplepage.js                                  webpack多页面测试环境配置文件\n|   webpack.config.js                                                   webpack单页面生产环境配置文件\n|   webpack.config.pro.multiplepage.js                                  webpack多页面生产环境配置文件\n|\n\\---src                                                                 代码根目录\n    |   admin-index.js                                                  admin后台入口文件\n    |   entry.js                                                        tes1页面入口文件\n    |   index-style.scss                                                \n    |   index.html                                                      页面模板文件\n    |   index.js                                                        前台页面入口文件\n    |\n    +---component                                                       组件目录\n    |   +---Admin                                                       admin后台组件目录\n    |   |   |   index.scss\n    |   |   |\n    |   |   +---Home                                                    \n    |   |   |   |   index.js\n    |   |   |   |   style.scss\n    |   |   |   |\n    |   |   |   \\---Articles                                            文章编辑列表组件\n    |   |   |           edit.js                                         文章编辑组件\n    |   |   |           index.js                                        文章列表\n    |   |   |           style.scss\n    |   |   |\n    |   |   +---LeftNav                                                 左边菜单栏\n    |   |   |       index.js\n    |   |   |       index.scss\n    |   |   |\n    |   |   \\---PublishArticle                                          发布文章组件\n    |   |           index.js\n    |   |           style.scss\n    |   |\n    |   +---Articles                                                    前台文章\n    |   |   |   index.js                                                前台文章列表组件\n    |   |   |   style.scss\n    |   |   |\n    |   |   \\---Article                                                 前台文章内容页\n    |   |           index.js\n    |   |\n    |   +---ConnectMe                                                   前台联系我组件\n    |   |       index.js\n    |   |\n    |   +---FeedBack                                                    前台反馈组件\n    |   |       index.js\n    |   |       style.scss\n    |   |\n    |   +---MDEditor                                                    markdown编辑器容器(可自定义，markdown主要代码不在这)\n    |   |       index.js\n    |   |\n    |   +---MyPagination                                                分页组件\n    |   |       index.js\n    |   |       style.scss\n    |   |\n    |   +---Notes\n    |   |       index.js\n    |   |       style.scss\n    |   |\n    |   +---PageFooter                                                  页尾\n    |   |       index.js\n    |   |       style.scss\n    |   |\n    |   +---PageHeader                                                  页头容器\n    |   |   |   index.js\n    |   |   |   style.scss\n    |   |   |\n    |   |   +---Header                                                  页头\n    |   |   |       index.js\n    |   |   |       style.scss\n    |   |   |\n    |   |   \\---HeaderNav                                               页头导航菜单\n    |   |           index.js\n    |   |           style.scss\n    |   |\n    |   +---PageIndex                                                   首页\n    |   |   |   index.js\n    |   |   |   style.scss\n    |   |   |\n    |   |   \\---IndexContent                                            首页内容\n    |   |           index.js\n    |   |           style.scss\n    |   |\n    |   \\---Profile                                                     个人资料\n    |           index.js\n    |           style.scss\n    |\n    +---config                                                          个人资料配置文件\n    |       profileConfig.js\n    |\n    +---lib                                                             markdown组件\n    |       editor.js\n    |       editor.less\n    |\n    +---static\n    |   +---css\n    |   |       amazeui.min.css\n    |   |       base.scss\n    |   |       codemirror.css                                          markdown样式文件\n    |   |\n    |   +---fonts\n    |   |       fontawesome-webfont.woff2\n    |   |\n    |   +---images\n    |   |       header.png\n    |   |       logo.png\n    |   |       profile_ico_b.png\n    |   |\n    |   \\---scss\n    |           component.scss                                          markdown sass文件\n    |           index.scss\n    |\n    \\---utils\n            amazeutil.js\n            autoChange.js\n            DataUtils.js\n```\n\n## webpack配置文件说明\n```\nwebpack.config.js：用于生产环境编译文件。\nwebpack.config.dev.js：用于开发阶段编译文件。修改react文件之后会自动编译  不需要手动编译\n```\n## 功能\n\n***markdown文本编辑功能***\n\n**关于eslint的使用**\n```\n作用：为避免低级 Bug、产出风格统一的代码，会预先制定编码规范。使用 Lint 工具和代码风格检测工具，则可以辅助编码规范执行，有效控制代码质量。\n\nps：由于第一次使用，还有很多规则没有写到，没写到的可以自己在.eslintrc配置文件增加。eslint会使在编写代码的时候会遇到很多问题...头疼，但是使用这个能是代码更规范！\n不需要的可以在webpack配置文件里面去掉下面两个配置：\npreLoaders: [\n  {\n    // Eslint loader\n    test: /\\.js?$/,\n    loader: 'eslint-loader',\n    include: [path.resolve(__dirname, 'src')],\n    exclude: [/node_modules/,path.resolve(__dirname, 'src/utils')],\n  },\n],\neslint: {\n  configFile: '.eslintrc',\n},\n```\n\n关于appMultiplePage.js和webpack.config.dev.multiplepage.js的说明\n```\n\"deploy-dev\": \"webpack -p --progress --colors\",\n\"deploy-dev-server\": \"webpack-dev-server --config webpack.config.dev.js --progress --colors\",                                                                 //开发环境单页面启动脚本\n\"deploy-server\": \"webpack -p --config webpack.config.js --progress --colors&&nodemon app.js\",                                                                 //生产环境单页面启动脚本\n\"multiple-page-dev\": \"node ./appMultiplePageDev.js\",                                                                                                          //开发环境多页面的服务启动入口脚本，根据配置文件的projectConf配置生成路由服务，结合react热加载，不需要手动重新编译，但是需要手动刷新页面。\n\"multiple-page-pro\": \"webpack -p --config webpack.config.pro.multiplepage.js&&node ./appMultiplePagePro.js\"                                                   //生产环境多页面服务启动脚本\n\nappMultiplePage.js：一个react多页面的服务启动入口js，根据配置文件的projectConf配置生成路由服务，结合react热加载，不需要手动重新编译，但是需要手动刷新页面。\nwebpack.config.dev.multiplepage.js：根据配置(config.js)自动生成多个页面的webpack配置文件\n\n多页面启动方式：\n先执行webpack --config webpack.config.dev.multiplepage.js --progress --color 编译项目，再启动多页面服务nodemon appMultiplePage.js\n或者执行script脚本npm run multiple-page-build再执行npm run nodemon appMultiplePage.js\n```\n\n\n***\n2016/12/23 \n- 增加[markdown编辑器](https://github.com/leozdgao/react-markdown)功能\n- 修改之前抽离css不成功bug\n\n","__v":0,"deleted":false,"publishDate":"2017-01-09T08:21:41.670Z","id":"70c71446-f6f2-40a9-874f-657ddbc02130"},{"_id":"5870bfc535b7c02b6c622142","title":"React Router 使用教程","author":"阮一峰","before":"真正学会 React 是一个漫长的过程。\n\n你会发现，它不是一个库，也不是一个框架，而是一个庞大的体系。想要发挥它的威力，整个技术栈都要配合它改造。你要学习一整套解决方案，从后端到前端，都是全新的做法。","content":"<p>真正学会<a href=\"https://facebook.github.io/react/\"> React</a> 是一个漫长的过程。</p>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016052501.jpg\" alt=\"alt\"></p>\n<p>你会发现，它不是一个库，也不是一个框架，而是一个庞大的体系。想要发挥它的威力，整个技术栈都要配合它改造。你要学习一整套解决方案，从后端到前端，都是全新的做法。</p>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016052503.png\" alt=\"alt\"></p>\n<p>举例来说，React 不使用 HTML，而使用 JSX 。它打算抛弃 DOM，要求开发者不要使用任何 DOM 方法。它甚至还抛弃了 SQL ，自己发明了一套查询语言 GraphQL 。当然，这些你都可以不用，React 照样运行，但是就发挥不出它的最大威力。</p>\n<p>这样说吧，你只要用了 React，就会发现合理的选择就是，采用它的整个技术栈。</p>\n<p>本文介绍 React 体系的一个重要部分：路由库<a href=\"https://github.com/reactjs/react-router\">React-Router</a>。它是官方维护的，事实上也是唯一可选的路由库。它通过管理 URL，实现组件的切换和状态的变化，开发复杂的应用几乎肯定会用到。</p>\n<p>本文针对初学者，尽量写得简洁易懂。预备知识是 React 的基本用法，可以参考我写的《React 入门实例教程》。\n另外，我没有准备示例库，因为官方的示例库非常棒，由浅入深，分成14步，每一步都有详细的代码解释。我强烈建议你先跟着做一遍，然后再看下面的API讲解。</p>\n<h2 id=\"-\">一、基本用法</h2>\n<p>React Router 安装命令如下。</p>\n<pre><code>$ npm install -S react-router\n</code></pre><p>使用时，路由器<code>Router</code>就是React的一个组件。</p>\n<pre><code>import { Router } from &#39;react-router&#39;;\nrender(&lt;Router/&gt;, document.getElementById(&#39;app&#39;));\n</code></pre><p>Router组件本身只是一个容器，真正的路由要通过<code>Route</code>组件定义。</p>\n<pre><code>import { Router, Route, hashHistory } from &#39;react-router&#39;;\n\nrender((\n  &lt;Router history={hashHistory}&gt;\n    &lt;Route path=&quot;/&quot; component={App}/&gt;\n  &lt;/Router&gt;\n), document.getElementById(&#39;app&#39;));\n</code></pre><p>上面代码中，用户访问根路由<code>/</code>（比如<code>http://www.example.com/</code>），组件APP就会加载到<code>document.getElementById(&#39;app&#39;)</code>。\n你可能还注意到，Router组件有一个参数history，它的值<code>hashHistory</code>表示，路由的切换由URL的hash变化决定，即URL的#部分发生变化。举例来说，用户访问<code>http://www.example.com/</code>，实际会看到的是<code>http://www.example.com/#/</code>。\nRoute组件定义了URL路径与组件的对应关系。你可以同时使用多个Route组件。</p>\n<pre><code>&lt;Router history={hashHistory}&gt;\n  &lt;Route path=&quot;/&quot; component={App}/&gt;\n  &lt;Route path=&quot;/repos&quot; component={Repos}/&gt;\n  &lt;Route path=&quot;/about&quot; component={About}/&gt;\n&lt;/Router&gt;\n</code></pre><p>上面代码中，用户访问/repos（比如<code>http://localhost:8080/#/repos</code>）时，加载Repos组件；访问/about（<code>http://localhost:8080/#/about</code>）时，加载About组件。</p>\n<h2 id=\"-\">二、嵌套路由</h2>\n<p>Route组件还可以嵌套。</p>\n<pre><code>&lt;Router history={hashHistory}&gt;\n  &lt;Route path=&quot;/&quot; component={App}&gt;\n    &lt;Route path=&quot;/repos&quot; component={Repos}/&gt;\n    &lt;Route path=&quot;/about&quot; component={About}/&gt;\n  &lt;/Route&gt;\n&lt;/Router&gt;\n</code></pre><p>上面代码中，用户访问/repos时，会先加载App组件，然后在它的内部再加载Repos组件。</p>\n<pre><code>&lt;App&gt;\n  &lt;Repos/&gt;\n&lt;/App&gt;\n</code></pre><p>App组件要写成下面的样子。</p>\n<pre><code>export default React.createClass({\n  render() {\n    return &lt;div&gt;\n      {this.props.children}\n    &lt;/div&gt;\n  }\n})\n</code></pre><p>上面代码中，App组件的this.props.children属性就是子组件。\n子路由也可以不写在Router组件里面，单独传入Router组件的routes属性。</p>\n<pre><code>let routes = &lt;Route path=&quot;/&quot; component={App}&gt;\n  &lt;Route path=&quot;/repos&quot; component={Repos}/&gt;\n  &lt;Route path=&quot;/about&quot; component={About}/&gt;\n&lt;/Route&gt;;\n\n&lt;Router routes={routes} history={browserHistory}/&gt;\n</code></pre><h2 id=\"-path-\">三、 path 属性</h2>\n<p>Route组件的path属性指定路由的匹配规则。这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件。\n请看下面的例子。</p>\n<pre><code>&lt;Route path=&quot;inbox&quot; component={Inbox}&gt;\n   &lt;Route path=&quot;messages/:id&quot; component={Message} /&gt;\n&lt;/Route&gt;\n</code></pre><p>上面代码中，当用户访问/inbox/messages/:id时，会加载下面的组件。</p>\n<pre><code class=\"lang-`\">&lt;Inbox&gt;\n  &lt;Message/&gt;\n&lt;/Inbox&gt;\n</code></pre>\n<p>如果省略外层Route的path参数，写成下面的样子。</p>\n<pre><code>&lt;Route component={Inbox}&gt;\n  &lt;Route path=&quot;inbox/messages/:id&quot; component={Message} /&gt;\n&lt;/Route&gt;\n</code></pre><p>现在用户访问<code>/inbox/messages/:id</code>时，组件加载还是原来的样子。</p>\n<pre><code>&lt;Inbox&gt;\n  &lt;Message/&gt;\n&lt;/Inbox&gt;\n</code></pre><h2 id=\"-\">四、通配符</h2>\n<p>path属性可以使用通配符。</p>\n<pre><code>&lt;Route path=&quot;/hello/:name&quot;&gt;\n// 匹配 /hello/michael\n// 匹配 /hello/ryan\n\n&lt;Route path=&quot;/hello(/:name)&quot;&gt;\n// 匹配 /hello\n// 匹配 /hello/michael\n// 匹配 /hello/ryan\n\n&lt;Route path=&quot;/files/*.*&quot;&gt;\n// 匹配 /files/hello.jpg\n// 匹配 /files/hello.html\n\n&lt;Route path=&quot;/files/*&quot;&gt;\n// 匹配 /files/ \n// 匹配 /files/a\n// 匹配 /files/a/b\n\n&lt;Route path=&quot;/**/*.jpg&quot;&gt;\n// 匹配 /files/hello.jpg\n// 匹配 /files/path/to/file.jpg\n</code></pre><p>通配符的规则如下。</p>\n<pre><code>（1）:paramName\n:paramName匹配URL的一个部分，直到遇到下一个/、?、#为止。这个路径参数可以通过this.props.params.paramName取出。\n（2）()\n()表示URL的这个部分是可选的。\n（3）*\n*匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。\n（4） **\n** 匹配任意字符，直到下一个/、?、#为止。匹配方式是贪婪模式。\n</code></pre><p>path属性也可以使用相对路径（不以<code>/</code>开头），匹配时就会相对于父组件的路径，可以参考上一节的例子。嵌套路由如果想摆脱这个规则，可以使用绝对路由。\n路由匹配规则是从上到下执行，一旦发现匹配，就不再其余的规则了。</p>\n<pre><code>&lt;Route path=&quot;/comments&quot; ... /&gt;\n&lt;Route path=&quot;/comments&quot; ... /&gt;\n</code></pre><p>上面代码中，路径/comments同时匹配两个规则，第二个规则不会生效。\n设置路径参数时，需要特别小心这一点。</p>\n<pre><code>&lt;Router&gt;\n  &lt;Route path=&quot;/:userName/:id&quot; component={UserPage}/&gt;\n  &lt;Route path=&quot;/about/me&quot; component={About}/&gt;\n&lt;/Router&gt;\n</code></pre><p>上面代码中，用户访问<code>/about/me</code>时，不会触发第二个路由规则，因为它会匹配<code>/:userName/:id</code>这个规则。因此，带参数的路径一般要写在路由规则的底部。\n此外，URL的查询字符串<code>/foo?bar=baz</code>，可以用<code>this.props.location.query.bar</code>获取。</p>\n<h2 id=\"-indexroute-\">五、IndexRoute 组件</h2>\n<p>下面的例子，你会不会觉得有一点问题？</p>\n<pre><code>&lt;Router&gt;\n  &lt;Route path=&quot;/&quot; component={App}&gt;\n    &lt;Route path=&quot;accounts&quot; component={Accounts}/&gt;\n    &lt;Route path=&quot;statements&quot; component={Statements}/&gt;\n  &lt;/Route&gt;\n&lt;/Router&gt;\n</code></pre><p>上面代码中，访问根路径/，不会加载任何子组件。也就是说，App组件的this.props.children，这时是undefined。\n因此，通常会采用{this.props.children || <Home/>}这样的写法。这时，Home明明是Accounts和Statements的同级组件，却没有写在Route中。\nIndexRoute就是解决这个问题，显式指定Home是根路由的子组件，即指定默认情况下加载的子组件。你可以把IndexRoute想象成某个路径的index.html。</p>\n<pre><code>&lt;Router&gt;\n  &lt;Route path=&quot;/&quot; component={App}&gt;\n    &lt;IndexRoute component={Home}/&gt;\n    &lt;Route path=&quot;accounts&quot; component={Accounts}/&gt;\n    &lt;Route path=&quot;statements&quot; component={Statements}/&gt;\n  &lt;/Route&gt;\n&lt;/Router&gt;\n</code></pre><p>现在，用户访问/的时候，加载的组件结构如下。</p>\n<pre><code>&lt;App&gt;\n  &lt;Home/&gt;\n&lt;/App&gt;\n</code></pre><p>这种组件结构就很清晰了：App只包含下级组件的共有元素，本身的展示内容则由Home组件定义。这样有利于代码分离，也有利于使用React Router提供的各种API。\n注意，IndexRoute组件没有路径参数path。</p>\n<h2 id=\"-redirect-\">六、Redirect 组件</h2>\n<p><Redirect>组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由。</p>\n<pre><code>&lt;Route path=&quot;inbox&quot; component={Inbox}&gt;\n  {/* 从 /inbox/messages/:id 跳转到 /messages/:id */}\n  ＜Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;\n&lt;/Route&gt;\n</code></pre><p>现在访问<code>/inbox/messages/5</code>，会自动跳转到<code>/messages/5</code>。</p>\n<h2 id=\"-indexredirect-\">七、IndexRedirect 组件</h2>\n<p>IndexRedirect组件用于访问根路由的时候，将用户重定向到某个子组件。</p>\n<pre><code>&lt;Route path=&quot;/&quot; component={App}&gt;\n  ＜IndexRedirect to=&quot;/welcome&quot; /&gt;\n  &lt;Route path=&quot;welcome&quot; component={Welcome} /&gt;\n  &lt;Route path=&quot;about&quot; component={About} /&gt;\n&lt;/Route&gt;\n</code></pre><p>上面代码中，用户访问根路径时，将自动重定向到子组件welcome。</p>\n<h2 id=\"-link\">八、Link</h2>\n<p>Link组件用于取代<code>&lt;a&gt;</code>元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是<code>&lt;a&gt;</code>元素的React 版本，可以接收Router的状态。</p>\n<pre><code>render() {\n  return &lt;div&gt;\n    &lt;ul role=&quot;nav&quot;&gt;\n      &lt;li&gt;&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;Link to=&quot;/repos&quot;&gt;Repos&lt;/Link&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n}\n</code></pre><p>如果希望当前的路由与其他路由有不同样式，这时可以使用Link组件的activeStyle属性。</p>\n<pre><code>&lt;Link to=&quot;/about&quot; activeStyle={{color: &#39;red&#39;}}&gt;About&lt;/Link&gt;\n&lt;Link to=&quot;/repos&quot; activeStyle={{color: &#39;red&#39;}}&gt;Repos&lt;/Link&gt;\n</code></pre><p>上面代码中，当前页面的链接会红色显示。\n另一种做法是，使用activeClassName指定当前路由的Class。</p>\n<pre><code>&lt;Link to=&quot;/about&quot; activeClassName=&quot;active&quot;&gt;About&lt;/Link&gt;\n&lt;Link to=&quot;/repos&quot; activeClassName=&quot;active&quot;&gt;Repos&lt;/Link&gt;\n</code></pre><p>上面代码中，当前页面的链接的class会包含active。\n在Router组件之外，导航到路由页面，可以使用浏览器的History API，像下面这样写。</p>\n<pre><code>import { browserHistory } from &#39;react-router&#39;;\nbrowserHistory.push(&#39;/some/path&#39;);\n</code></pre><h2 id=\"-indexlink\">九、IndexLink</h2>\n<p>如果链接到根路由/，不要使用Link组件，而要使用IndexLink组件。\n这是因为对于根路由来说，activeStyle和activeClassName会失效，或者说总是生效，因为/会匹配任何子路由。而IndexLink组件会使用路径的精确匹配。</p>\n<pre><code>&lt;IndexLink to=&quot;/&quot; activeClassName=&quot;active&quot;&gt;\n  Home\n&lt;/IndexLink&gt;\n</code></pre><p>上面代码中，根路由只会在精确匹配时，才具有<code>activeClassName</code>。\n另一种方法是使用Link组件的<code>onlyActiveOnIndex</code>属性，也能达到同样效果。</p>\n<pre><code>&lt;Link to=&quot;/&quot; activeClassName=&quot;active&quot; onlyActiveOnIndex={true}&gt;\n  Home\n&lt;/Link&gt;\n</code></pre><p>实际上，IndexLink就是对Link组件的onlyActiveOnIndex属性的包装。</p>\n<h2 id=\"-histroy-\">十、histroy 属性</h2>\n<p>Router组件的history属性，用来监听浏览器地址栏的变化，并将URL解析成一个地址对象，供 React Router 匹配。\nhistory属性，一共可以设置三种值。</p>\n<pre><code>- browserHistory\n- hashHistory\n- createMemoryHistory\n</code></pre><p>如果设为hashHistory，路由将通过URL的hash部分（<code>#</code>）切换，URL的形式类似<code>example.com/#/some/path</code>。</p>\n<pre><code>import { hashHistory } from &#39;react-router&#39;\n\nrender(\n  &lt;Router history={hashHistory} routes={routes} /&gt;,\n  document.getElementById(&#39;app&#39;)\n)\n</code></pre><p>如果设为<code>browserHistory</code>，浏览器的路由就不再通过Hash完成了，而显示正常的路径<code>example.com/some/path</code>，背后调用的是浏览器的History API。</p>\n<pre><code>import { browserHistory } from &#39;react-router&#39;\n\nrender(\n  &lt;Router history={browserHistory} routes={routes} /&gt;,\n  document.getElementById(&#39;app&#39;)\n)\n</code></pre><p>但是，这种情况需要对服务器改造。否则用户直接向服务器请求某个子路由，会显示网页找不到的404错误。\n如果开发服务器使用的是webpack-dev-server，加上--history-api-fallback参数就可以了。</p>\n<pre><code>$ webpack-dev-server --inline --content-base . --history-api-fallback\n</code></pre><p>createMemoryHistory主要用于服务器渲染。它创建一个内存中的history对象，不与浏览器URL互动。</p>\n<pre><code>const history = createMemoryHistory(location)\n</code></pre><h2 id=\"-\">十一、表单处理</h2>\n<p>Link组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作。这些情况怎么跟React Router对接呢？\n下面是一个表单。</p>\n<pre><code>&lt;form onSubmit={this.handleSubmit}&gt;\n  &lt;input type=&quot;text&quot; placeholder=&quot;userName&quot;/&gt;\n  &lt;input type=&quot;text&quot; placeholder=&quot;repo&quot;/&gt;\n  &lt;button type=&quot;submit&quot;&gt;Go&lt;/button&gt;\n&lt;/form&gt;\n</code></pre><p>第一种方法是使用<code>browserHistory.push</code></p>\n<pre><code>import { browserHistory } from &#39;react-router&#39;\n\n// ...\n  handleSubmit(event) {\n    event.preventDefault()\n    const userName = event.target.elements[0].value\n    const repo = event.target.elements[1].value\n    const path = `/repos/${userName}/${repo}`\n    browserHistory.push(path)\n  },\n</code></pre><p>第二种方法是使用context对象。</p>\n<pre><code>export default React.createClass({\n\n  // ask for `router` from context\n  contextTypes: {\n    router: React.PropTypes.object\n  },\n\n  handleSubmit(event) {\n    // ...\n    this.context.router.push(path)\n  },\n})\n</code></pre><h2 id=\"-\">十二、路由的钩子</h2>\n<p>每个路由都有Enter和Leave钩子，用户进入或离开该路由时触发。</p>\n<pre><code>&lt;Route path=&quot;about&quot; component={About} /&gt;\n＜Route path=&quot;inbox&quot; component={Inbox}&gt;\n  ＜Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;\n&lt;/Route&gt;\n</code></pre><p>上面的代码中，如果用户离开/messages/:id，进入/about时，会依次触发以下的钩子。</p>\n<pre><code>/messages/:id的onLeave\n/inbox的onLeave\n/about的onEnter\n</code></pre><p>下面是一个例子，使用<code>onEnter</code>钩子替代<code>&lt;Redirect&gt;</code>组件。</p>\n<pre><code>&lt;Route path=&quot;inbox&quot; component={Inbox}&gt;\n  &lt;Route\n    path=&quot;messages/:id&quot;\n    onEnter={\n      ({params}, replace) =&gt; replace(`/messages/${params.id}`)\n    } \n  /&gt;\n&lt;/Route&gt;\n</code></pre><p>onEnter钩子还可以用来做认证。</p>\n<pre><code>const requireAuth = (nextState, replace) =&gt; {\n    if (!auth.isAdmin()) {\n        // Redirect to Home page if not an Admin\n        replace({ pathname: &#39;/&#39; })\n    }\n}\nexport const AdminRoutes = () =&gt; {\n  return (\n     &lt;Route path=&quot;/admin&quot; component={Admin} onEnter={requireAuth} /&gt;\n  )\n}\n</code></pre><p>下面是一个高级应用，当用户离开一个路径的时候，跳出一个提示框，要求用户确认是否离开。</p>\n<pre><code>const Home = withRouter(\n  React.createClass({\n    componentDidMount() {\n      this.props.router.setRouteLeaveHook(\n        this.props.route, \n        this.routerWillLeave\n      )\n    },\n\n    routerWillLeave(nextLocation) {\n      // 返回 false 会继续停留当前页面，\n      // 否则，返回一个字符串，会显示给用户，让其自己决定\n      if (!this.state.isSaved)\n        return &#39;确认要离开？&#39;;\n    },\n  })\n)\n</code></pre><p>上面代码中，<code>setRouteLeaveHook</code>方法为Leave钩子指定<code>routerWillLeave</code>函数。该方法如果返回false，将阻止路由的切换，否则就返回一个字符串，提示用户决定是否要切换。</p>\n<hr>\n<p>转自: <a href=\"http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu\">http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu</a></p>\n","origin":"真正学会[ React](https://facebook.github.io/react/) 是一个漫长的过程。\n\n![alt](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016052501.jpg)\n\n你会发现，它不是一个库，也不是一个框架，而是一个庞大的体系。想要发挥它的威力，整个技术栈都要配合它改造。你要学习一整套解决方案，从后端到前端，都是全新的做法。\n\n![alt](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016052503.png)\n\n举例来说，React 不使用 HTML，而使用 JSX 。它打算抛弃 DOM，要求开发者不要使用任何 DOM 方法。它甚至还抛弃了 SQL ，自己发明了一套查询语言 GraphQL 。当然，这些你都可以不用，React 照样运行，但是就发挥不出它的最大威力。\n\n这样说吧，你只要用了 React，就会发现合理的选择就是，采用它的整个技术栈。\n\n本文介绍 React 体系的一个重要部分：路由库[React-Router](https://github.com/reactjs/react-router)。它是官方维护的，事实上也是唯一可选的路由库。它通过管理 URL，实现组件的切换和状态的变化，开发复杂的应用几乎肯定会用到。\n\n本文针对初学者，尽量写得简洁易懂。预备知识是 React 的基本用法，可以参考我写的《React 入门实例教程》。\n另外，我没有准备示例库，因为官方的示例库非常棒，由浅入深，分成14步，每一步都有详细的代码解释。我强烈建议你先跟着做一遍，然后再看下面的API讲解。\n## 一、基本用法\nReact Router 安装命令如下。\n```\n$ npm install -S react-router\n```\n使用时，路由器```Router```就是React的一个组件。\n```\nimport { Router } from 'react-router';\nrender(<Router/>, document.getElementById('app'));\n```\nRouter组件本身只是一个容器，真正的路由要通过```Route```组件定义。\n```\nimport { Router, Route, hashHistory } from 'react-router';\n\nrender((\n  <Router history={hashHistory}>\n    <Route path=\"/\" component={App}/>\n  </Router>\n), document.getElementById('app'));\n```\n\n上面代码中，用户访问根路由```/```（比如```http://www.example.com/```），组件APP就会加载到```document.getElementById('app')```。\n你可能还注意到，Router组件有一个参数history，它的值```hashHistory```表示，路由的切换由URL的hash变化决定，即URL的#部分发生变化。举例来说，用户访问```http://www.example.com/```，实际会看到的是```http://www.example.com/#/```。\nRoute组件定义了URL路径与组件的对应关系。你可以同时使用多个Route组件。\n\n```\n<Router history={hashHistory}>\n  <Route path=\"/\" component={App}/>\n  <Route path=\"/repos\" component={Repos}/>\n  <Route path=\"/about\" component={About}/>\n</Router>\n```\n上面代码中，用户访问/repos（比如```http://localhost:8080/#/repos```）时，加载Repos组件；访问/about（```http://localhost:8080/#/about```）时，加载About组件。\n## 二、嵌套路由\nRoute组件还可以嵌套。\n\n```\n<Router history={hashHistory}>\n  <Route path=\"/\" component={App}>\n    <Route path=\"/repos\" component={Repos}/>\n    <Route path=\"/about\" component={About}/>\n  </Route>\n</Router>\n```\n\n上面代码中，用户访问/repos时，会先加载App组件，然后在它的内部再加载Repos组件。\n```\n<App>\n  <Repos/>\n</App>\n```\nApp组件要写成下面的样子。\n```\nexport default React.createClass({\n  render() {\n    return <div>\n      {this.props.children}\n    </div>\n  }\n})\n```\n上面代码中，App组件的this.props.children属性就是子组件。\n子路由也可以不写在Router组件里面，单独传入Router组件的routes属性。\n```\nlet routes = <Route path=\"/\" component={App}>\n  <Route path=\"/repos\" component={Repos}/>\n  <Route path=\"/about\" component={About}/>\n</Route>;\n\n<Router routes={routes} history={browserHistory}/>\n```\n## 三、 path 属性\nRoute组件的path属性指定路由的匹配规则。这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件。\n请看下面的例子。\n```\n<Route path=\"inbox\" component={Inbox}>\n   <Route path=\"messages/:id\" component={Message} />\n</Route>\n```\n上面代码中，当用户访问/inbox/messages/:id时，会加载下面的组件。\n````\n<Inbox>\n  <Message/>\n</Inbox>\n```\n如果省略外层Route的path参数，写成下面的样子。\n```\n<Route component={Inbox}>\n  <Route path=\"inbox/messages/:id\" component={Message} />\n</Route>\n```\n现在用户访问```/inbox/messages/:id```时，组件加载还是原来的样子。\n```\n<Inbox>\n  <Message/>\n</Inbox>\n```\n## 四、通配符\npath属性可以使用通配符。\n```\n<Route path=\"/hello/:name\">\n// 匹配 /hello/michael\n// 匹配 /hello/ryan\n\n<Route path=\"/hello(/:name)\">\n// 匹配 /hello\n// 匹配 /hello/michael\n// 匹配 /hello/ryan\n\n<Route path=\"/files/*.*\">\n// 匹配 /files/hello.jpg\n// 匹配 /files/hello.html\n\n<Route path=\"/files/*\">\n// 匹配 /files/ \n// 匹配 /files/a\n// 匹配 /files/a/b\n\n<Route path=\"/**/*.jpg\">\n// 匹配 /files/hello.jpg\n// 匹配 /files/path/to/file.jpg\n```\n通配符的规则如下。\n```\n（1）:paramName\n:paramName匹配URL的一个部分，直到遇到下一个/、?、#为止。这个路径参数可以通过this.props.params.paramName取出。\n（2）()\n()表示URL的这个部分是可选的。\n（3）*\n*匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。\n（4） **\n** 匹配任意字符，直到下一个/、?、#为止。匹配方式是贪婪模式。\n```\npath属性也可以使用相对路径（不以```/```开头），匹配时就会相对于父组件的路径，可以参考上一节的例子。嵌套路由如果想摆脱这个规则，可以使用绝对路由。\n路由匹配规则是从上到下执行，一旦发现匹配，就不再其余的规则了。\n```\n<Route path=\"/comments\" ... />\n<Route path=\"/comments\" ... />\n```\n上面代码中，路径/comments同时匹配两个规则，第二个规则不会生效。\n设置路径参数时，需要特别小心这一点。\n```\n<Router>\n  <Route path=\"/:userName/:id\" component={UserPage}/>\n  <Route path=\"/about/me\" component={About}/>\n</Router>\n```\n上面代码中，用户访问```/about/me```时，不会触发第二个路由规则，因为它会匹配```/:userName/:id```这个规则。因此，带参数的路径一般要写在路由规则的底部。\n此外，URL的查询字符串```/foo?bar=baz```，可以用```this.props.location.query.bar```获取。\n## 五、IndexRoute 组件\n下面的例子，你会不会觉得有一点问题？\n```\n<Router>\n  <Route path=\"/\" component={App}>\n    <Route path=\"accounts\" component={Accounts}/>\n    <Route path=\"statements\" component={Statements}/>\n  </Route>\n</Router>\n```\n上面代码中，访问根路径/，不会加载任何子组件。也就是说，App组件的this.props.children，这时是undefined。\n因此，通常会采用{this.props.children || <Home/>}这样的写法。这时，Home明明是Accounts和Statements的同级组件，却没有写在Route中。\nIndexRoute就是解决这个问题，显式指定Home是根路由的子组件，即指定默认情况下加载的子组件。你可以把IndexRoute想象成某个路径的index.html。\n```\n<Router>\n  <Route path=\"/\" component={App}>\n    <IndexRoute component={Home}/>\n    <Route path=\"accounts\" component={Accounts}/>\n    <Route path=\"statements\" component={Statements}/>\n  </Route>\n</Router>\n```\n现在，用户访问/的时候，加载的组件结构如下。\n```\n<App>\n  <Home/>\n</App>\n```\n这种组件结构就很清晰了：App只包含下级组件的共有元素，本身的展示内容则由Home组件定义。这样有利于代码分离，也有利于使用React Router提供的各种API。\n注意，IndexRoute组件没有路径参数path。\n## 六、Redirect 组件\n<Redirect>组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由。\n```\n<Route path=\"inbox\" component={Inbox}>\n  {/* 从 /inbox/messages/:id 跳转到 /messages/:id */}\n  ＜Redirect from=\"messages/:id\" to=\"/messages/:id\" />\n</Route>\n```\n现在访问```/inbox/messages/5```，会自动跳转到```/messages/5```。\n## 七、IndexRedirect 组件\nIndexRedirect组件用于访问根路由的时候，将用户重定向到某个子组件。\n```\n<Route path=\"/\" component={App}>\n  ＜IndexRedirect to=\"/welcome\" />\n  <Route path=\"welcome\" component={Welcome} />\n  <Route path=\"about\" component={About} />\n</Route>\n```\n上面代码中，用户访问根路径时，将自动重定向到子组件welcome。\n## 八、Link\nLink组件用于取代```<a>```元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是```<a>```元素的React 版本，可以接收Router的状态。\n```\nrender() {\n  return <div>\n    <ul role=\"nav\">\n      <li><Link to=\"/about\">About</Link></li>\n      <li><Link to=\"/repos\">Repos</Link></li>\n    </ul>\n  </div>\n}\n```\n如果希望当前的路由与其他路由有不同样式，这时可以使用Link组件的activeStyle属性。\n```\n<Link to=\"/about\" activeStyle={{color: 'red'}}>About</Link>\n<Link to=\"/repos\" activeStyle={{color: 'red'}}>Repos</Link>\n```\n上面代码中，当前页面的链接会红色显示。\n另一种做法是，使用activeClassName指定当前路由的Class。\n```\n<Link to=\"/about\" activeClassName=\"active\">About</Link>\n<Link to=\"/repos\" activeClassName=\"active\">Repos</Link>\n```\n上面代码中，当前页面的链接的class会包含active。\n在Router组件之外，导航到路由页面，可以使用浏览器的History API，像下面这样写。\n```\nimport { browserHistory } from 'react-router';\nbrowserHistory.push('/some/path');\n```\n## 九、IndexLink\n如果链接到根路由/，不要使用Link组件，而要使用IndexLink组件。\n这是因为对于根路由来说，activeStyle和activeClassName会失效，或者说总是生效，因为/会匹配任何子路由。而IndexLink组件会使用路径的精确匹配。\n```\n<IndexLink to=\"/\" activeClassName=\"active\">\n  Home\n</IndexLink>\n```\n上面代码中，根路由只会在精确匹配时，才具有```activeClassName```。\n另一种方法是使用Link组件的```onlyActiveOnIndex```属性，也能达到同样效果。\n```\n<Link to=\"/\" activeClassName=\"active\" onlyActiveOnIndex={true}>\n  Home\n</Link>\n```\n实际上，IndexLink就是对Link组件的onlyActiveOnIndex属性的包装。\n## 十、histroy 属性\nRouter组件的history属性，用来监听浏览器地址栏的变化，并将URL解析成一个地址对象，供 React Router 匹配。\nhistory属性，一共可以设置三种值。\n```\n- browserHistory\n- hashHistory\n- createMemoryHistory\n```\n\n\n如果设为hashHistory，路由将通过URL的hash部分（```#```）切换，URL的形式类似```example.com/#/some/path```。\n```\nimport { hashHistory } from 'react-router'\n\nrender(\n  <Router history={hashHistory} routes={routes} />,\n  document.getElementById('app')\n)\n```\n如果设为```browserHistory```，浏览器的路由就不再通过Hash完成了，而显示正常的路径```example.com/some/path```，背后调用的是浏览器的History API。\n```\nimport { browserHistory } from 'react-router'\n\nrender(\n  <Router history={browserHistory} routes={routes} />,\n  document.getElementById('app')\n)\n```\n但是，这种情况需要对服务器改造。否则用户直接向服务器请求某个子路由，会显示网页找不到的404错误。\n如果开发服务器使用的是webpack-dev-server，加上--history-api-fallback参数就可以了。\n```\n$ webpack-dev-server --inline --content-base . --history-api-fallback\n```\n\ncreateMemoryHistory主要用于服务器渲染。它创建一个内存中的history对象，不与浏览器URL互动。\n\n```\nconst history = createMemoryHistory(location)\n```\n\n## 十一、表单处理\nLink组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作。这些情况怎么跟React Router对接呢？\n下面是一个表单。\n\n```\n<form onSubmit={this.handleSubmit}>\n  <input type=\"text\" placeholder=\"userName\"/>\n  <input type=\"text\" placeholder=\"repo\"/>\n  <button type=\"submit\">Go</button>\n</form>\n```\n\n第一种方法是使用```browserHistory.push```\n\n```\nimport { browserHistory } from 'react-router'\n\n// ...\n  handleSubmit(event) {\n    event.preventDefault()\n    const userName = event.target.elements[0].value\n    const repo = event.target.elements[1].value\n    const path = `/repos/${userName}/${repo}`\n    browserHistory.push(path)\n  },\n```\n第二种方法是使用context对象。\n```\nexport default React.createClass({\n\n  // ask for `router` from context\n  contextTypes: {\n    router: React.PropTypes.object\n  },\n\n  handleSubmit(event) {\n    // ...\n    this.context.router.push(path)\n  },\n})\n```\n## 十二、路由的钩子\n每个路由都有Enter和Leave钩子，用户进入或离开该路由时触发。\n```\n<Route path=\"about\" component={About} />\n＜Route path=\"inbox\" component={Inbox}>\n  ＜Redirect from=\"messages/:id\" to=\"/messages/:id\" />\n</Route>\n```\n上面的代码中，如果用户离开/messages/:id，进入/about时，会依次触发以下的钩子。\n```\n/messages/:id的onLeave\n/inbox的onLeave\n/about的onEnter\n```\n下面是一个例子，使用```onEnter```钩子替代```<Redirect>```组件。\n```\n<Route path=\"inbox\" component={Inbox}>\n  <Route\n    path=\"messages/:id\"\n    onEnter={\n      ({params}, replace) => replace(`/messages/${params.id}`)\n    } \n  />\n</Route>\n```\nonEnter钩子还可以用来做认证。\n```\nconst requireAuth = (nextState, replace) => {\n    if (!auth.isAdmin()) {\n        // Redirect to Home page if not an Admin\n        replace({ pathname: '/' })\n    }\n}\nexport const AdminRoutes = () => {\n  return (\n     <Route path=\"/admin\" component={Admin} onEnter={requireAuth} />\n  )\n}\n```\n下面是一个高级应用，当用户离开一个路径的时候，跳出一个提示框，要求用户确认是否离开。\n```\nconst Home = withRouter(\n  React.createClass({\n    componentDidMount() {\n      this.props.router.setRouteLeaveHook(\n        this.props.route, \n        this.routerWillLeave\n      )\n    },\n\n    routerWillLeave(nextLocation) {\n      // 返回 false 会继续停留当前页面，\n      // 否则，返回一个字符串，会显示给用户，让其自己决定\n      if (!this.state.isSaved)\n        return '确认要离开？';\n    },\n  })\n)\n```\n上面代码中，```setRouteLeaveHook```方法为Leave钩子指定```routerWillLeave```函数。该方法如果返回false，将阻止路由的切换，否则就返回一个字符串，提示用户决定是否要切换。\n***\n转自: http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu","__v":0,"deleted":false,"publishDate":"2017-01-07T10:15:33.233Z","id":"fb0b6b95-ac54-4602-b340-e5ab0e17c110"},{"_id":"5870584dac64fe0d04d58af6","title":"Express 解析 json 格式 post 数据","author":"zzhi","before":"关于前端不加Content-Type=application/json，node后端req.body获取字段为空的解决办法","content":"<blockquote>\n<p>node.js 下著名web框架 express ,对于解析json格式数据之前低版本需要依赖 bodyParser .\n后来的版本把 bodyParser 继承进去.\n使用的时候需要在express 配置项里\nuser(express.bodyParser({ keepExtensions: true, uploadDir: ‘/tmp’ }))</p>\n</blockquote>\n<p>如下代码:</p>\n<pre><code>var express = require(&#39;express&#39;),\n    app = express();\n\napp.configure(function () {\n    app.use(express.bodyParser({ keepExtensions: true, uploadDir: &#39;/tmp&#39; }));\n});\n</code></pre><p><strong>Express 升级到4.x版本以后</strong></p>\n<blockquote>\n<p>升级以后的Express 所有的依赖包都拿出来了.\n所以,如果你用了  Express 4.x 的某个版本来解析 json 方式的post请求数据\n需要安装 body-parser</p>\n<pre><code>npm install body-parser\n</code></pre></blockquote>\n<p> 如果你的接口要求post 上来的数据格式是这样的:</p>\n<pre><code>{&quot;data&quot;:{&quot;name&quot;:&quot;一介布衣&quot;,&quot;url&quot;:&quot;http://yijiebuyi.com&quot;}}\n</code></pre><p> 后端express 进过 bodyParser 的解析后,可以这样读取到数据</p>\n<pre><code>req.body.data.name    获取到  一介布衣\nreq.body.data.url      获取到 http://yijiebuyi.com\n</code></pre><p>这里是有前提的,客户端请求接口时必须指名请求头类型 </p>\n<pre><code>Content-Type=application/json\n</code></pre><p> bodyParser 发现这样类型的请求头后,会自动将 body 里的 json 格式数据正确解析,否则 req.body.data 为 undefined<br>传统的服务器端语言可能会接收post上传的流,然后转成字符串最后在格式化成 json ,这样加不加application/json 请求头都是没有问题的<br> 但是Express 中间件在解析body中的post参数会检查 Content-Type 类型,所以没有指定正确格式导致中间件解析参数出错. </p>\n<p>那如何处理呢?</p>\n<p> 因为好多地方都在调用你的接口,你无法保证所有的人都在请求头里面加了 Content-Type=application/json</p>\n<p>解决思路是:</p>\n<blockquote>\n<p>服务器端 先用 req.body.data 参数获取参数,如果成功,说明 bodyParser 正确解析了json 参数. 还是按照之前的方法读取.<br> 如果 req.body.data 参数无值或者undefined 那么我们也用流来读取post 数据,然后转成字符串再解析成 json 格式来使用. 直接上代码</p>\n</blockquote>\n<pre><code>app.post(&#39;/post&#39;, function (req, res) {\n    if (req.body.data) {\n        //能正确解析 json 格式的post参数\n        res.send({&quot;status&quot;: &quot;success&quot;, &quot;name&quot;: req.body.data.name, &quot;url&quot;: req.body.data.url});\n    } else {\n        //不能正确解析json 格式的post参数\n        var body = &#39;&#39;, jsonStr;\n        req.on(&#39;data&#39;, function (chunk) {\n            body += chunk; //读取参数流转化为字符串\n        });\n        req.on(&#39;end&#39;, function () {\n            //读取参数流结束后将转化的body字符串解析成 JSON 格式\n            try {\n                jsonStr = JSON.parse(body);\n            } catch (err) {\n                jsonStr = null;\n            }\n            jsonStr ? res.send({&quot;status&quot;:&quot;success&quot;, &quot;name&quot;: jsonStr.data.name, &quot;url&quot;: jsonStr.data.url}) : res.send({&quot;status&quot;:&quot;error&quot;});\n        });\n    }\n});\n</code></pre><p>转自：<a href=\"https://cnodejs.org/topic/54929c5561491ead0cc7bff2\">https://cnodejs.org/topic/54929c5561491ead0cc7bff2</a></p>\n","origin":">node.js 下著名web框架 express ,对于解析json格式数据之前低版本需要依赖 bodyParser .\n后来的版本把 bodyParser 继承进去.\n使用的时候需要在express 配置项里\nuser(express.bodyParser({ keepExtensions: true, uploadDir: ‘/tmp’ }))\n\n如下代码:\n```\nvar express = require('express'),\n    app = express();\n\napp.configure(function () {\n    app.use(express.bodyParser({ keepExtensions: true, uploadDir: '/tmp' }));\n});\n```\n**Express 升级到4.x版本以后**\n\n> 升级以后的Express 所有的依赖包都拿出来了.\n所以,如果你用了  Express 4.x 的某个版本来解析 json 方式的post请求数据\n需要安装 body-parser\n```\nnpm install body-parser\n```\n\n 如果你的接口要求post 上来的数据格式是这样的:\n```\n{\"data\":{\"name\":\"一介布衣\",\"url\":\"http://yijiebuyi.com\"}}\n```\n 后端express 进过 bodyParser 的解析后,可以这样读取到数据\n```\nreq.body.data.name    获取到  一介布衣\nreq.body.data.url      获取到 http://yijiebuyi.com \n```\n这里是有前提的,客户端请求接口时必须指名请求头类型 \n```\nContent-Type=application/json\n```\n\n bodyParser 发现这样类型的请求头后,会自动将 body 里的 json 格式数据正确解析,否则 req.body.data 为 undefined  \n传统的服务器端语言可能会接收post上传的流,然后转成字符串最后在格式化成 json ,这样加不加application/json 请求头都是没有问题的  \n 但是Express 中间件在解析body中的post参数会检查 Content-Type 类型,所以没有指定正确格式导致中间件解析参数出错. \n\n那如何处理呢?\n\n 因为好多地方都在调用你的接口,你无法保证所有的人都在请求头里面加了 Content-Type=application/json\n\n解决思路是:\n\n >服务器端 先用 req.body.data 参数获取参数,如果成功,说明 bodyParser 正确解析了json 参数. 还是按照之前的方法读取.  \n 如果 req.body.data 参数无值或者undefined 那么我们也用流来���取post 数据,然后转成字符串再解析成 json 格式来使用. 直接上代码\n\n```\napp.post('/post', function (req, res) {\n    if (req.body.data) {\n        //能正确解析 json 格式的post参数\n        res.send({\"status\": \"success\", \"name\": req.body.data.name, \"url\": req.body.data.url});\n    } else {\n        //不能正确解析json 格式的post参数\n        var body = '', jsonStr;\n        req.on('data', function (chunk) {\n            body += chunk; //读取参数流转化为字符串\n        });\n        req.on('end', function () {\n            //读取参数流结束后将转化的body字符串解析成 JSON 格式\n            try {\n                jsonStr = JSON.parse(body);\n            } catch (err) {\n                jsonStr = null;\n            }\n            jsonStr ? res.send({\"status\":\"success\", \"name\": jsonStr.data.name, \"url\": jsonStr.data.url}) : res.send({\"status\":\"error\"});\n        });\n    }\n});\n```\n转自：https://cnodejs.org/topic/54929c5561491ead0cc7bff2","__v":0,"deleted":false,"publishDate":"2017-01-07T02:54:05.609Z","id":"9aa8f4b7-73c2-4ac1-b853-ce18bbd45d93"}],"total":4},"message":""}